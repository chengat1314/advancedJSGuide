<div id="traps" class="step">
	<h2>小心，JavaScript 有陷阱</h2>
</div>

<div id="traps-plus" class="step">
	<h4><code>+</code></h4>
	<p>作为二元运算符时，它既是数学运算的加法，也是字符串的拼接</p>
	<pre><code class="javascript"><%= codes.traps_plus %></code></pre>
</div>

<div id="traps-plus-decision" class="step">
	<p>如何决定一段代码中的 <code>+</code> 是数学运算还是字符串拼接？</p>
	<pre><code><%= codes.traps_plus_descision %></code></pre>
	<ul>
		<li>收集 <code>+</code> 两端的操作数的**原始值**</li>
		<li>如果其中之一是字符串，则进行字符串拼接</li>
		<li>否则，执行数学加法</li>
	</ul>
</div>

<div id="with" class="step">
	<h4><code>with</code></h4>
	<p>将一个语句块的上下文绑定到一个指定对象</p>
	<pre><code class="javascript"><%= codes.with %></code></pre>
</div>

<div id="dont-use-with" class="step">
	<p>不推荐使用 <code>with</code> 语句</p>
	<ul>
		<li>JS 解释器引擎难以对代码执行优化</li>
		<li>代码可读性差</li>
	</ul>
</div>

<div id="semicolon" class="step">
	<h4><code>;</code> 自动插入</h4>
	<p>在语句结束时，你不必手动输入分号，换行即可</p>
	<pre><code class="javascript"><%= codes.asi %></code></pre>
</div>

<div id="semicolon" class="step">
	<p>过于依赖分号自动插入，将带来一些潜在问题</p>
	<pre><code class="javascript"><%= codes.bad_asi %></code></pre>
</div>

<div id="hoisting" class="step">
	<h4>声明提升</h4>
	<pre><code class="javascript"><%= codes.hoisting_a %></code></pre>
</div>

<div id="hoisting-b" class="step">
	<h4>声明提升</h4>
	<pre><code class="javascript"><%= codes.hoisting_b %></code></pre>
</div>

<div id="hoisted" class="step">
	<h4>声明提升</h4>
	<p>变量的声明、函数的声明将提升到当前函数主体的顶部，而不管这个声明语句是否出现在了不可到达的地方</p>
	<pre><code class="javascript"><%= codes.hoisted %></code></pre>
</div>

<div id="eval" class="step">
	<h4><code>eval</code></h4>
	<p><code>eval</code> 是 JavaScript 的动态特性之一</p>
	<pre><code class="php"><%= codes.eval %></code></pre>
</div>

<div id="dont-use-eval" class="step">
	<p>不推荐使用 <code>eval</code></p>
	<ul>
		<li>JS 解释器引擎难以对代码执行优化</li>
		<li><code>eval</code> 中传递的字符串中大多包含用户输入数据，易受攻击</li>
		<li><code>eval</code> 中的语句代码的可阅读性差</li>
		<li>相对 <code>eval</code>，使用等同的函数式编程，将更高效和安全</li>
	</ul>
</div>

<div id="multi-line" class="step">
	<h4>多行字符串</h4>
	<pre><code class="javascript"><%= codes.multi_line %></code></pre>
</div>

<div id="multi-line" class="step">
	<p>假设我们后期做一些维护</p>
	<pre><code class="javascript"><%= codes.multi_line_modified %></code></pre>
</div>

<div id="pollute" class="step">
	<p>变量泄露</p>
	<pre><code class="javascript"><%= codes.pollute %></code></pre>
</div>

<div id="arguments" class="step">
	<h4><code>arguments.callee</code></h4>
	<h4>递归函数</h4>
	<pre><code class="javascript"><%= codes.recursive %></code></pre>
</div>

<div id="anonymous" class="step">
	<h4>不想污染命名空间，匿名函数如何递归？</h4>
	<pre><code class="javascript"><%= codes.anonymous %></code></pre>
</div>

<div id="callee" class="step">
	<h4>我们有 <code>arguments.callee</code></h4>
	<pre><code class="javascript"><%= codes.callee %></code></pre>
</div>

<div id="dont-use-eval" class="step">
	<p>不推荐使用 <code>eval</code></p>
	<ul>
		<li>访问 <code>arguments.callee</code> 的开销是昂贵的</li>
		<li>使用它将导致 JS 解释器难以执行优化</li>
		<li>从 ECMAScript 3 开始，已经支持**有命名函数表达式**</li>
	</ul>
</div>

<div id="named-func-expr" class="step">
	<p>有命名函数表达式</p>
	<pre><code class="javascript"><%= codes.named_func_expr %></code></pre>
</div>