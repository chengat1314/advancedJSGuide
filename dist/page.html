<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=1024">
<meta name="apple-mobile-web-app-capable" content="yes">
<title>JavaScript 进阶 - weareoutman</title>
<link href="http://fonts.googleapis.com/css?family=Open+Sans:regular,semibold,italic,italicsemibold|PT+Sans:400,700,400italic,700italic|PT+Serif:400,700,400italic,700italic" rel="stylesheet">
<link rel="stylesheet" type="text/css" href="style.css">
<link rel="stylesheet" type="text/css" href="github.css">
</head>
<body>
<div id="impress" data-transition-duration="400">

<div id="cover" class="step">
	<h1>JavaScript 进阶</h1>
</div>

<div id="current" class="step">
	<h2>JavaScript 现状</h2>
	<p>现代Web浏览器唯一指定编程语言</p>
	<p>Node.js 盛行</p>
	<p>JavaScript 是当今世界最流行的编程语言之一</p>
</div>

<div id="misunderstood" class="step">
	<h3>JavaScript : 世界上被误解最多的编程语言</h3>
	<p style="text-align:right;padding-right:4em;">-- Douglas Crockford</p>
</div>

<div id="mis-name" class="step">
	<h4>关于名字 - JavaScript </h4>
	<dl>
		<dt>JavaScript 不是 Java ！</dt>
		<dt>JavaScript 是一门解释性脚本语言</dt>
		<dd>与 C 相比，它牺牲了性能，以提升动态特性和开发效率</dd>
	</dl>
</div>

<div id="typecast" class="step">
	<h3>JavaScript 被定型</h3>
	<p>它只能在Web浏览器里跑？</p>
	<ul>
		<li>在服务端：Node.js</li>
		<li>在桌面客户端：Windows 8</li>
	</ul>
</div>

<div id="design-error" class="step">
	<h3>JavaScript 有设计上的失误</h3>
	<p>没有一门编程语言是完美的</p>
	<ul>
		<li><code>+</code> 号被同时用作数字的加法，以及字符串的拼接</li>
		<li><code>with</code> 语句</li>
		<li><code>;</code> 自动插入</li>
	</ul>
</div>

<!-- <div id="amateur" class="step">
	<h3>业余/入门开发者</h3>
	<ul>
		<li>门槛低</li>
		<li>语法陷阱</li>
		<li>错误的指导</li>
	</ul>
</div> -->

<div id="is-it-object-oriented" class="step">
	<h3>JavaScript 是面向对象的？</h3>
	<p>它连 <code>class</code> 都没有！</p>
</div>

<div id="feature" class="step">
	<h2>JavaScript 特性</h2>
	<ul>
		<li>类似C的结构化编程</li>
		<li>动态</li>
		<li>函数式编程</li>
		<li>基于原型的面向对象</li>
	</ul>
</div>

<div id="structured" class="step">
	<h3>类似C的结构化编程</h3>
	<pre><code class="javascript">// 条件语句
if (lilei.money &gt;= 1e6 &amp;&amp; lilei.house &gt;= 1) {
	lilei.marry(hanmeimei);
} else {
	lilei.dieAlone();
}

// 循环语句
while (lilei.money &lt; 1e6 &amp;&amp; lilei.house === 0) {
	lilei.writeCodes();
}

// 选择语句
switch (lilei.workHoursPerDay) {
	case 0: case 1: /* ... */ case 7:
		company.fire(lilei);
		break;
	case 8:
		company.pay(lilei, 3000);
		break;
	case 9:
		company.pay(lilei, 4000);
		break;
	/* ... */
	case 24:
		lilei.die();
}</code></pre>
</div>

<div id="dynamic" class="step">
	<h3>JavaScript 动态特性</h3>
	<ul>
		<li>动态类型</li>
		<li>Eval</li>
		<li>对象动态更新</li>
		<li>反射</li>
	</ul>
</div>

<div id="dynamic-type" class="step">
	<h4>动态类型</h4>
	<p><code>type</code> 与 <code>value</code> 关联，而不是与 <code>variable</code></p>
	<pre><code class="javascript">var foo = 1;
foo = "A string";
foo = [1, 2];
foo = new Date();
foo = function(){};</code></pre>
</div>

<div id="dynamic-eval" class="step">
	<h4>Eval</h4>
	<p>在运行时，将给定的字符串当作代码语句执行</p>
	<pre><code class="php">&lt;script&gt;
var func = &lt;?php echo json_encode($user_send['func']); ?&gt;;
eval(func + "()");
function sayHello() {}
function sayGoodbye() {}
&lt;/script&gt;</code></pre>
</div>

<div id="object-alternation" class="step">
	<h4>对象动态更新</h4>
	<p>对象的属性和方法都可以在运行时，增加、修改、删除</p>
	<pre><code class="javascript">var obj = {
	prop: "value"
};

// 增加方法
obj.other = function(){};
// 修改属性
obj.prop = "new value";
// 删除属性
delete obj.prop;</code></pre>
</div>

<div id="reflection" class="step">
	<h3>反射</h3>
	<pre><code class="javascript">var obj = {
	foo: "value",
	bar: function() {
		return this.foo;
	}
};

// 使用字符串访问对象的属性或方法
console.log(obj.foo === obj["foo"]);

// 遍历对象的属性和方法
for (var key in obj) {
	console.log(key, obj[key]);
}</code></pre>
</div>

<div id="functional" class="step">
	<h3>函数式编程</h3>
	<h4>First-class function</h4>
	<p>函数是 JavaScript 中的一等公民</p>
</div>

<div id="function-can-do" class="step">
	<h4>函数可以做哪些事？</h4>
	<ul>
		<li>作为参数传递</li>
		<li>作为另一个函数的返回值</li>
		<li>赋值给一个变量</li>
		<li>作为对象的一个方法</li>
	</ul>
	<pre><code class="javascript">var bind = function(func, target) {
	return function() {
		func.apply(target, arguments);
	};
};

var utils = {
	trim: function(str) {
		return str.replace(/^\s+|\s+$/g, "");
	}
};</code></pre>
</div>

<div id="variadic" class="step">
	<h4>可变参数</h4>
	<p>函数的参数数量没有限制</p>
	<p>可以通过参数名或者 <code>arguments</code> 对象来访问参数</p>
	<pre><code class="javascript">(function(){
	// `arguments` 拥有数组的外观，可以通过数字下标访问各个参数
	var arg1 = arguments[0], // 1
		arg2 = arguments[1]; // 2

	// 但它并不是数组
	console.log(arguments instanceof Array); // false
	console.log(arguments.slice); // undefined

	// 对 arguments 进行数组相关操作
	var argElse = Array.prototype.slice.call(arguments, 2);
	console.log(argElse); // [3, 4]
})(1, 2, 3, 4);</code></pre>
</div>

<div id="scope" class="step">
	<h4>作用域</h4>
	<p>C语言中的 <code>block scope</code> :</p>
	<pre><code class="c">int function foo(void) {
	int bar = 1;
	{
		int bar = 2;
	}
	return bar; // 1
}</code></pre>
	<p>JS 中的 <code>function scope</code> :</p>
	<pre><code class="javascript">function foo() {
	var bar = 1;
	{
		var bar = 2;
	}
	return bar; // 2
}</code></pre>
</div>

<div id="scope-chain" class="step">
	<h4>Scope chain 作用域链</h4>
	<p>访问一个变量时，会从本地变量和参数开始，逐级向上遍历作用域直到 <code>global scope</code></p>
	<pre><code class="javascript">var scope = 0, zero = "global-scope";
(function(){
	var scope = 1, one = "scope-1";
	(function(){
		var scope = 2, two = "scope-2";
		(function(){
			var scope = 3, three = "scope-3";
			// scope-3 scope-2 scope-1 global-scope
			console.log([three, two, one, zero].join(" "));
			console.log(scope); // 3
		})();
		console.log(typeof three); // undefined
		console.log(scope); // 2
	})();
	console.log(typeof two); // undefined
	console.log(scope); // 1
})();
console.log(typeof one); // undefined
console.log(scope); // 0</code></pre>
</div>

<div id="nested-function" class="step">
	<h4>Closure 闭包</h4>
	<p>在一个函数中，定义另一个函数，称为函数嵌套。函数的嵌套将形成一个闭包。</p>
	<pre><code class="javascript">function bind(func, target) {
	return function() {
		func.apply(target, arguments);
	};
}</code></pre>
</div>

<div id="closure" class="step">
	<h4>如何理解闭包？</h4>
	<ul>
		<li>外部函数不能访问内嵌函数。</li>
		<li>外部函数也不能访问内嵌函数的参数和变量。</li>
		<li>而内嵌函数可以访问外部函数的参数和变量。</li>
		<li>换一个说法：内嵌函数包含了外部函数的作用域。</li>
	</ul>
	<pre><code class="javascript">var scope = 0, zero = "global-scope";
(function(){
	var scope = 1, one = "scope-1";
	(function(){
		var scope = 2, two = "scope-2";
		(function(){
			var scope = 3, three = "scope-3";
			// scope-3 scope-2 scope-1 global-scope
			console.log([three, two, one, zero].join(" "));
			console.log(scope); // 3
		})();
		console.log(typeof three); // undefined
		console.log(scope); // 2
	})();
	console.log(typeof two); // undefined
	console.log(scope); // 1
})();
console.log(typeof one); // undefined
console.log(scope); // 0</code></pre>
</div>

<div id="closure-2" class="step">
	<h4>如何理解闭包？</h4>
	<ul>
		<li>每次外部函数的调用，内嵌函数都会被创建一次。</li>
		<li>在它被创建时，外部函数的作用域（包括任何本地变量、参数等上下文），会成为每个内嵌函数对象的内部状态的一部分，即使在外部函数执行完并退出后</li>
	</ul>
	<pre><code class="javascript">function bind(func, target) {
	return function() {
		func.apply(target, arguments);
	};
}

function foo(bar) {
	console.log(this.count += bar);
}

var counterA = { count: 0 };
var counterB = { count: 0 };

var increaseA = bind(foo, counterA);
var increaseB = bind(foo, counterB);

increaseA(1); // 1
console.log(counterA.count); // 1
console.log(counterB.count); // 0

increaseB(2); // 2
increaseB(3); // 5
console.log(counterA.count); // 1
console.log(counterB.count); // 5</code></pre>
</div>

<div id="object-oriented" class="step">
	<h3>JavaScript 是面向对象的</h3>
	<p>JavaScript : 基于原型的面向对象</p>
</div>

<div id="class" class="step">
	<h4>类</h4>
	<p>JavaScript 中没有 <code>class</code> ，<code>function</code> 即 <code>class</code></p>
	<pre><code class="javascript">function Person() { }</code></pre>
</div>

<div id="instance" class="step">
	<h4>对象 - 类的实例</h4>
	<p>使用 <code>new Func</code> 将创建一个 <code>Func</code> 的实例</p>
	<pre><code class="javascript">function Person() { }
var lilei = new Person();
var hanmeimei = new Person();</code></pre>
</div>

<div id="constructor" class="step">
	<h4>构造器</h4>
	<p><code>function</code> 即 <code>constructor</code></p>
	<pre><code class="javascript">function Person() {
	console.log("A person is born");
}
var lilei = new Person();
console.log(lilei.constructor === Person); // true</code></pre>
</div>

<div id="property" class="step">
	<h4>属性和方法</h4>
	<p>通过关键字 <code>this</code> 或构造器(函数)的 <code>prototype</code> 来设置类的属性和方法</p>
	<pre><code class="javascript">function Person(gender) {
	this.gender = gender || "unkown";
}

Person.prototype.sayHello = function() {
	console.log("Hello world!");
};

var lilei = new Person();
var hanmeimei = new Person();</code></pre>
</div>

<div id="inheritance" class="step">
	<h4>继承</h4>
	<p>通过将子类的 <code>prototype</code> 赋值为父类的一个实例，来实现继承</p>
	<pre><code class="javascript">function Student() {
	Person.call(this);
}

Student.prototype = new Person();
// Student.prototype = Object.create(Person.prototype);

Student.prototype.constructor = Student;

Student.prototype.sayHello = function() {
	console.log("Hello school!");
};

Student.prototype.sayGoodbye = function() {
	console.log("Goodbye school!");
};

var lilei = new Student();

lilei.sayHello();
lilei.sayGoodbye();

console.log(lilei instanceof Person);  // true
console.log(lilei instanceof Student); // true</code></pre>
</div>

<div id="traps" class="step">
	<h2>小心，JavaScript 陷阱重重</h2>
</div>

<div id="traps-plus" class="step">
	<h4><code>+</code> 加号</h4>
	<p>作为二元运算符时，它既是数学运算的加法，也是字符串的拼接</p>
	<pre><code class="javascript">console.log(   1 + 2   );
console.log( "3" + "4" );

console.log(   1 + "3" );
console.log( "3" + 1   );

console.log( 1 + null      );
console.log( 1 + undefined );
console.log( 1 + NaN       );

console.log( "3" + null      );
console.log( "3" + undefined );
console.log( "3" + NaN       );

console.log( 1 + {} );
console.log( 1 + [] );

console.log( "3" + {} );
console.log( "3" + [] );</code></pre>
</div>

<div id="traps-plus-decision" class="step">
	<h4><code>+</code> 加号</h4>
	<p>如何决定一段代码中的 <code>+</code> 是数学运算还是字符串拼接？</p>
	<pre><code>a + b:
	pa = ToPrimitive(a)
	pb = ToPrimitive(b)
	if (pa is string || pb is string)
		return concat(ToString(pa), ToString(pb))
	else
		return add(ToNumber(pa), ToNumber(pb))</code></pre>
	<ul>
		<li>收集 <code>+</code> 两端的操作数的**原始值**</li>
		<li>如果其中之一是字符串，则进行字符串拼接</li>
		<li>否则，执行数学加法</li>
	</ul>
</div>

<div id="with" class="step">
	<h4><code>with</code></h4>
	<p>将一个语句块的上下文绑定到一个指定对象</p>
	<pre><code class="javascript">with (document) {
	write("foo");
	getElemntById("bar").innerHTML = "foobar";
	alert("Hello world!");
}

// document.write("foo");
// document.getElemntById("bar").innerHTML = "foobar";
// window.alert("Hello world!");</code></pre>
</div>

<div id="dont-use-with" class="step">
	<h4><code>with</code></h4>
	<p>不推荐使用 <code>with</code> 语句</p>
	<ul>
		<li>JS 解释器引擎难以对代码执行优化</li>
		<li>代码可读性差</li>
	</ul>
	<pre><code class="javascript">with (document) {
	write("foo");
	getElemntById("bar").innerHTML = "foobar";
	alert("Hello world!");
}

// document.write("foo");
// document.getElemntById("bar").innerHTML = "foobar";
// window.alert("Hello world!");</code></pre>
</div>

<div id="asi" class="step">
	<h4><code>;</code> 分号自动插入</h4>
	<p>在语句结束时，你不必手动输入分号，换行即可</p>
	<pre><code class="javascript">function foo() {
	var bar = "value"
	return bar
}

// `{}` 包围的语句块的最后一个语句的分号也可省略
function bar() { return "foo" }</code></pre>
</div>

<div id="bad-asi" class="step">
	<h4><code>;</code> 分号自动插入</h4>
	<p>过于依赖分号自动插入，将带来一些潜在问题</p>
	<pre><code class="javascript">function foo() {
	return
	{
		bar: 1
	}
}

function bar() {
	var a, b, c, d, e
	a = b + c
	(d + e).toString()

	// a = b + c(d + e).toString();
}</code></pre>
</div>

<div id="hoisting" class="step">
	<h4>声明提升</h4>
	<p>看看这段代码，我们将得到什么结果？</p>
	<pre><code class="javascript">var foo = 1;
function bar() {
	// 这个条件成立吗？
	if (! foo) {
		var foo = 10;
	}
	alert(foo);
}
bar();</code></pre>
</div>

<div id="hoisting-b" class="step">
	<h4>声明提升</h4>
	<p>那么这段代码呢？</p>
	<pre><code class="javascript">var a = 1;
function b() {
	a = 10;
	return;
	function a() {}
}
b();
alert(a);</code></pre>
</div>

<div id="hoisted" class="step">
	<h4>声明提升</h4>
	<p>变量的声明、函数的声明将提升到当前函数主体的顶部，而不管这个声明语句是否出现在了不可到达的地方</p>
	<div class="code-2-col">
		<pre><code class="javascript">var foo = 1;
function bar() {
	// 这个条件成立吗？
	if (! foo) {
		var foo = 10;
	}
	alert(foo);
}
bar();

var a = 1;
function b() {
	a = 10;
	return;
	function a() {}
}
b();
alert(a);</code></pre>
		<pre><code class="javascript">var foo = 1;
function bar() {
	var foo;
	if (! foo) {
		foo = 10;
	}
	alert(foo);
}
bar();

var a = 1;
function b() {
	function a() {}
	a = 10;
	return;
}
b();
alert(a);</code></pre>
	</div>
</div>

<div id="eval" class="step">
	<h4><code>eval</code></h4>
	<p><code>eval</code> 是 JavaScript 的动态特性之一</p>
	<pre><code class="php">&lt;script&gt;
var func = &lt;?php echo json_encode($user_send['func']); ?&gt;;
eval(func + "()");
function sayHello() {}
function sayGoodbye() {}
&lt;/script&gt;</code></pre>
</div>

<div id="dont-use-eval" class="step">
	<h4><code>eval</code></h4>
	<p>不推荐使用 <code>eval</code></p>
	<ul>
		<li>JS 解释器引擎难以对代码执行优化</li>
		<li><code>eval</code> 中传递的字符串中大多包含用户输入数据，易受攻击</li>
		<li><code>eval</code> 中的语句代码的可阅读性差</li>
		<li>相对 <code>eval</code>，使用等同的函数式编程，将更高效和安全</li>
	</ul>
</div>

<div id="multi-line" class="step">
	<h4>多行字符串</h4>
	<pre><code class="javascript">var multiStr = "this is a multi-line string, \
and this is the second line. \
yes, the string ends here";</code></pre>
</div>

<div id="multi-line-modified" class="step">
	<h4>多行字符串</h4>
	<p>假设我们后期做一些维护</p>
	<pre><code class="javascript">var multiStr = "this is a multi-line string, \
and this is the second line. \ 
now i want to insert a line right here, \
yes, the string ends here";</code></pre>
</div>

<div id="pollute" class="step">
	<h4>变量泄露</h4>
	<pre><code class="javascript">function foo() {
	var type = "first";

	// do some jobs

	typo = "second";

	// do some else

	return type;
}

foo();</code></pre>
</div>

<div id="arguments" class="step">
	<h4><code>arguments.callee</code></h4>
	<p>递归函数</p>
	<pre><code class="javascript">function factorial(n) {
	return n &lt;= 1 ? 1 : factorial(n - 1) * n;
}
[1, 2, 3, 4, 5].map(factorial);</code></pre>
</div>

<div id="anonymous" class="step">
	<h4><code>arguments.callee</code></h4>
	<p>不想污染命名空间，匿名函数如何递归？</p>
	<pre><code class="javascript">[1, 2, 3, 4, 5].map(function(n) {
	return n &lt;= 1 ? 1 : /* what goes here? */ (n - 1) * n;
});</code></pre>
</div>

<div id="callee" class="step">
	<h4><code>arguments.callee</code></h4>
	<p>我们有 <code>arguments.callee</code></p>
	<pre><code class="javascript">[1, 2, 3, 4, 5].map(function(n) {
	return n &lt;= 1 ? 1 : arguments.callee(n - 1) * n;
});</code></pre>
</div>

<div id="dont-use-callee" class="step">
	<h4><code>arguments.callee</code></h4>
	<p>不推荐使用 <code>arguments.callee</code></p>
	<ul>
		<li>访问 <code>arguments.callee</code> 的开销是昂贵的</li>
		<li>使用它将导致 JS 解释器难以执行优化</li>
		<li>从 ECMAScript 3 开始，已经支持**命名函数表达式**</li>
	</ul>
</div>

<div id="named-func-expr" class="step">
	<h4><code>arguments.callee</code></h4>
	<p>命名函数表达式</p>
	<pre><code class="javascript">[1, 2, 3, 4, 5].map(function factorial(n) {
	return n &lt;= 1 ? 1 : factorial(n - 1) * n;
});</code></pre>
</div>

<div id="quality" class="step">
	<h2>代码质量</h2>
	<dl>
		<dt>JavaScript 有太多的语法陷阱</dt>
		<dd>如何避免？</dd>
		<dt>JavaScript 灵活、开发效率高，我们可以非常轻易地实现大多数需求</dt>
		<dd>如何保证代码质量？</dd>
	</dl>
</div>

<div id="strict-mode" class="step">
	<h3>严格模式</h3>
	<pre><code class="javascript">function foo() {
	"use strict";

	// now foo is in strict mode

	function bar() {
		// in strict mode too
	}
}</code></pre>
</div>

<div id="what-is-strict-mode" class="step">
	<h3>严格模式</h3>
	<ul>
		<li>普通模式下的一些静默的错误，严格模式将抛出异常</li>
		<li>避免使用一些让 JS 解释器引擎难以执行优化的操作</li>
	</ul>
</div>

<div id="what-does-strict-mode-do" class="step">
	<h4>严格模式做些什么？</h4>
	<ul>
		<li>防止意外的创建全局变量。不能再为一个没有声明的变量赋值</li>
		<li>对象字面量中的属性名称必须是唯一的</li>
		<li>函数的各个参数名称必须是唯一的</li>
		<li>禁用 <code>with</code> 语句</li>
		<li><code>eval</code> 中严格模式的代码，不会将新的变量引入到当前作用域</li>
		<li>禁用 <code>arguments.callee</code> , <code>func.caller</code> , <code>func.arguments</code> </li>
		<li>新增了一些保留关键字 <code>implements</code>, <code>interface</code>, <code>package</code>, <code>private</code>, ... </li>
	</ul>
</div>

<div id="strict-mode-is-not-enough" class="step">
	<h4>严格模式不是万能的</h4>
	<ul>
		<li><code>strict mode</code> 能力有限</li>
		<li>它需要你的代码运行起来，才能通知你出问题了</li>
		<li>它不能对使用 ES3 标准的浏览器起效</li>
	</ul>
</div>

<div id="quality-tool" class="step">
	<h3>代码质量工具</h3>
	<p>JavaScript 中一款优秀的代码质量工具 -- JSHint</p>
	<p>它帮助检测 JavaScript 代码的错误和潜在问题</p>
</div>

<div id="jshint" class="step">
	<h4>JSHint</h4>
	<p>JSHint 是由 JSLint 分叉（fork）而来的<br>
	( JSLint 的作者是著名 JS 权威 Douglas Crockford )<br>
	JSHint 的发起者是 Anton Kovalyov，JSHint 是社区推动的</p>
</div>

<div id="jshint-runs-on" class="step">
	<h4>JSHint</h4>
	<p>JSHint 本身使用 JavaScript 开发<br>
	因此既可以运行在浏览器中，也可以运行在 Node.js 平台</p>
	<ul>
		<li>在官方网站上粘贴代码，点击按钮</li>
		<li>安装 Node.js 包，在命令行运行</li>
		<li>为你的代码编辑器增加一个插件</li>
		<li>配置在自动任务工具中</li>
	</ul>
</div>

<div id="jshint-enforcing" class="step">
	<h4>JSHint</h4>
	<p>强制选项示例：</p>
	<table>
		<tr>
			<th>选项</th>
			<th>说明</th>
		</tr>
		<tr>
			<td><code>curly</code></td>
			<td>循环和条件语句块，始终带上 `{ }`</td>
		</tr>
		<tr>
			<td><code>eqeqeq</code></td>
			<td>禁止使用 <code>==</code> 和 <code>!=</code>，而应使用 <code>===</code> 和 <code>!==</code></td>
		</tr>
		<tr>
			<td><code>es3</code></td>
			<td>使用 ECMAScript 3 规范，以兼容老浏览器 IE 6/7/8</td>
		</tr>
		<tr>
			<td><code>forin</code></td>
			<td>要求在 <code>forin</code> 循环里使用 `hasOwnProperty()` 过滤属性</td>
		</tr>
		<tr>
			<td><code>latedef</code></td>
			<td>禁止在一个变量声明前使用它</td>
		</tr>
		<tr>
			<td><code>noarg</code></td>
			<td>禁止使用 <code>arguments.caller</code> 和 <code>func.caller</code></td>
		</tr>
		<tr>
			<td><code>quotmark</code></td>
			<td>保证引号一致性</td>
		</tr>
		<tr>
			<td><code>undef</code></td>
			<td>禁止使用明显未声明的变量</td>
		</tr>
		<tr>
			<td><code>strict</code></td>
			<td>要求所有函数运行在 ECMAScript 5 的严格模式下</td>
		</tr>
		<tr>
			<td><code>trailing</code></td>
			<td>禁止行尾空白</td>
		</tr>
		<tr>
			<td><code>maxdepth</code></td>
			<td>控制代码块的最大嵌套深度</td>
		</tr>
		<tr>
			<td><code>maxstatements</code></td>
			<td>控制每个函数的最大语句数</td>
		</tr>
	</table>
</div>

<div id="jshint-relaxing" class="step">
	<h4>JSHint</h4>
	<p>松散选项示例：</p>
	<table>
		<tr>
			<th>选项</th>
			<th>说明</th>
		</tr>
		<tr>
			<td><code>asi</code></td>
			<td>允许分号缺失</td>
		</tr>
		<tr>
			<td><code>boss</code></td>
			<td>允许在期望是比较运算的地方使用赋值表达式</td>
		</tr>
		<tr>
			<td><code>evil</code></td>
			<td>允许使用 <code>eval</code></td>
		</tr>
		<tr>
			<td><code>multistr</code></td>
			<td>允许多行字符串（但仍会提示将导致错误的行尾空白）</td>
		</tr>
	</table>
</div>

<div id="unit-test" class="step">
	<h2>单元测试</h2>
	<h3>QUnit</h3>
	<p>QUnit 最初是著名JS库 jQuery 的一部分，后来独立出来作为一个JS单元测试框架</p>
</div>

<div id="unit-test-example" class="step">
	<h4>QUnit 示例</h4>
	<pre><code class="javascript">test("traps of +", function() {
	expect(14);

	strictEqual(1 + 2, 3);
	strictEqual("3" + "4", "34");

	strictEqual(1 + "3", "13");
	strictEqual("3" + 1, "31");

	strictEqual(1 + null, 1);
	ok(isNaN(1 + undefined));
	ok(isNaN(1 + NaN));

	strictEqual("3" + null, "3null");
	strictEqual("3" + undefined, "3undefined");
	strictEqual("3" + NaN, "3NaN");

	strictEqual(1 + {}, "1[object Object]");
	strictEqual(1 + [], "1");

	strictEqual("3" + {}, "3[object Object]");
	strictEqual("3" + [], "3");
});</code></pre>
</div>

<div id="automation" class="step">
	<h2>自动任务工具</h2>
	<h3>Grunt</h3>
	<p>"grunt" 的意思是 "打呼噜"，其目标就是让开发者们一劳永逸</p>
</div>

<div id="grunt-example" class="step">
	<h3>Grunt</h3>
	<p><code>Gruntfile.js</code> 示例</p>
	<pre><code class="javascript">var fs = require("fs");

function htmlspecialchars(str) {
	return str.replace(/&amp;/g, "&amp;amp;").replace(/&lt;/g, "&amp;lt;").replace(/&gt;/g, "&amp;gt;");
}

function replaceJshintComments(str) {
	return str.replace(/[ \t]*\/\*\s*(jshint|global)\s+[\s\w\,\:\-]+\*\/(?:\r?\n|\r)/, "");
}

module.exports = function(grunt) {

	// 幻灯片名称列表
	var slideList = [
		"cover",
		"current", /*"popular",*/ "misunderstood",
		"feature", "structured", "dynamic", "functional", "scope", "closure",
		"object-oriented", "class", "instance", "constructor", "property", "inheritance",
		"traps", "quality", "test", "automation",
		"thanks"
	];

	// 遍历获取幻灯片文件名
	var slides = [];
	slideList.forEach(function(name){
		slides.push("slides/" + name + ".html");
	});
	slides.unshift("src/intro.html");
	slides.push("src/outro.html");

	var pages = slides.slice(0);
	pages.splice(-1, 0, "src/no-impress.html");

	// 遍历获取示例代码文件内容
	var codes = {};
	var codeDirs = ["codes", "bad-codes"];
	codeDirs.forEach(function(dir){
		var codeList = fs.readdirSync(dir);
		codeList.forEach(function(name){
			var key = name.replace(/\.[^\.]+/, "");
			codes[key] = replaceJshintComments(htmlspecialchars(fs.readFileSync(dir + "/" + name).toString("utf8")));
		});
	});

	codes.Gruntfile = htmlspecialchars(fs.readFileSync("Gruntfile.js").toString("utf8"));

	// 配置
	grunt.initConfig({
		// pkg: grunt.file.readJSON("package.json"),
		codes: codes,
		concat: {
			options: {
				separator: "\n\n",
				process: true
			},
			dist: {
				// src: ["src/intro.html", "slides/cover.html", "src/outro.html"],
				src: slides,
				dest: "dist/index.html"
			},
			page: {
				src: pages,
				dest: "dist/page.html"
			}
		},
		jshint: {
			options: {
				"jshintrc": ".jshintrc"
			},
			dist: ["Gruntfile.js", "dist/main.js", "codes/*.js"]
		},
		uglify: {
			impress: {
				src: "dist/impress.js",
				dest: "dist/impress.min.js",
			}
		},
		qunit: {
			all: ["test/*.html"]
		}
	});

	// 载入任务
	grunt.loadNpmTasks("grunt-contrib-concat");
	grunt.loadNpmTasks("grunt-contrib-jshint");
	grunt.loadNpmTasks("grunt-contrib-uglify");
	grunt.loadNpmTasks("grunt-contrib-qunit");

	// 注册任务
	grunt.registerTask("default", ["jshint", "concat:dist", "concat:page"]);

	grunt.registerTask("impress", ["uglify:impress"]);
	grunt.registerTask("test", ["qunit"]);
};</code></pre>
</div>

<div id="what-does-grunt-do" class="step">
	<h3>Grunt</h3>
	<p>Grunt 使用 Node.js 实现<br>
	配合丰富的任务插件，Grunt可以将许多的开发任务自动化</p>
	<ul>
		<li>JSHint</li>
		<li>QUnit (with PhantomJS)</li>
		<li>UglifyJS</li>
		<li>RequireJS</li>
		<li>Concat</li>
		<li>Watch</li>
		<li>CoffeeScript / Less / Sass</li>
		<li>CssLint / CssMin / HtmlMin</li>
		<li>...</li>
	</ul>
</div>

<div id="about-this-presentation" class="step">
	<h2>关于本演示文稿</h2>
	<dl>
		<dd>源代码托管在 <a href="https://github.com/weareoutman/advancedJSGuide">https://github.com/weareoutman/advancedJSGuide</a></dd>
		<dd>在线演示版本 <a href="http://weareoutman.github.io/advancedJSGuide/">http://weareoutman.github.io/advancedJSGuide/</a></dd>
		<dd>在线普通版本 <a href="http://weareoutman.github.io/advancedJSGuide/">http://weareoutman.github.io/advancedJSGuide/page.html</a></dd>
	</dl>
</div>

<div id="thanks" class="step">
	<p>谢谢！</p>
</div>

<script type="text/javascript">
window.noImpress = true;
</script>

</div>

<div class="banner">
	研发中心 - 王沈伟
</div>

<script type="text/javascript" src="impress.js"></script>
<script type="text/javascript" src="highlight.pack.js"></script>
<script type="text/javascript" src="main.js"></script>
</body>
</html>